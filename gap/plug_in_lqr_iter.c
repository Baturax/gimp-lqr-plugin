/* plug_in_lqr_iter.c
 * generated by gap_filter_codegen.c
 * generation date:  29.07.108 03:03
 *
 * generation source Gimp PDB entry name: plug_in_lqr
 *                            version   : 2007
 *
 * The generated code will not work if the internal data stucture
 * (used to store and retrieve "LastValues") is different to the
 * PDB Calling Interface.
 *
 * In that case you will get an Error message like that:
 *       ERROR: xxxx_Iterator stored Data missmatch in size N != M
 *    if the Iterator is called. 
 *    (via "Filter all Layers" using "Apply Varying" Button)
 *
 *    When you get this Error, you should change this generated code.
 *  
 */

#define VALS_MAX_NAME_LENGTH (40)
#define sstrncpy(dest, src, n) { strncpy((dest),(src),(n)); (dest)[(n)-1]='\0'; }

/* SYTEM (UNIX) includes */ 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* GIMP includes */
#include "gtk/gtk.h"
#include "libgimp/gimp.h"

typedef struct { guchar color[3]; } t_color; 
typedef struct { gint color[3]; }   t_gint_color; 

gint p_plug_in_lqr_iter(GimpRunMode run_mode, gint32 total_steps, gdouble current_step, gint32 len_struct);
static void query(void); 
static void run(const gchar *name, gint nparam, const GimpParam *param, gint *nretvals, GimpParam **retvals); 

GimpPlugInInfo PLUG_IN_INFO = 
{
  NULL,  /* init_proc */ 
  NULL,  /* quit_proc */ 
  query, /* query_proc */ 
  run,   /* run_proc */ 
}; 

/* ----------------------------------------------------------------------
 * iterator functions for basic datatypes 
 * ----------------------------------------------------------------------
 */

static void p_delta_long(long *val, long val_from, long val_to, gint32 total_steps, gdouble current_step)
{
    double     delta;

    if(total_steps < 1) return;

    delta = ((double)(val_to - val_from) / (double)total_steps) * ((double)total_steps - current_step);
    *val  = val_from + delta;  
}
static void p_delta_gfloat(gfloat *val, gfloat val_from, gfloat val_to, gint32 total_steps, gdouble current_step)
{
    double     delta;

    if(total_steps < 1) return;

    delta = ((double)(val_to - val_from) / (double)total_steps) * ((double)total_steps - current_step);
    *val  = val_from + delta;
}

/* ----------------------------------------------------------------------
 * p_plug_in_lqr_iter 
 * ----------------------------------------------------------------------
 */
gint p_plug_in_lqr_iter(GimpRunMode run_mode, gint32 total_steps, gdouble current_step, gint32 len_struct) 
{
    typedef struct t_plug_in_lqr_Vals 
    {
      long      width;
      long      height;
      long      pres_layer;
      long      pres_coeff;
      long      disc_layer;
      long      disc_coeff;
      gfloat   rigidity;
      long      rigidity_mask_layer;
      long      delta_x;
      long      resize_aux_layers;
      long      resize_canvas;
      long      new_layer;
      long      seams;
      long      grad_func;
      long      res_order;
      long      mask_behavior;
      long      oper_mode;
      gchar	pres_layer_name[VALS_MAX_NAME_LENGTH];
      gchar	disc_layer_name[VALS_MAX_NAME_LENGTH];
      gchar	rigmask_layer_name[VALS_MAX_NAME_LENGTH];

    } t_plug_in_lqr_Vals; 

    t_plug_in_lqr_Vals  buf, buf_from, buf_to; 

    if(len_struct != sizeof(t_plug_in_lqr_Vals)) 
    {
      fprintf(stderr, "ERROR: p_plug_in_lqr_iter  stored Data missmatch in size %d != %d\n",   
                       (int)len_struct, sizeof(t_plug_in_lqr_Vals) ); 
      return -1;  /* ERROR */ 
    }

    gimp_get_data("plug_in_lqr-ITER-FROM", &buf_from); 
    gimp_get_data("plug_in_lqr-ITER-TO",   &buf_to); 
    memcpy(&buf, &buf_from, sizeof(buf));
    /*
    printf("[FROM] w,h= %li,%li pl_ID= %li pl_k= %li dl_ID= %li dl_k= %li r= %g ml_ID= %li dx= %li a?= %li c?= %li n?= %li s?= %li gf= %li ro= %li mb= %li om= %li\n",
      buf_from.width, buf_from.height, buf_from.pres_layer, buf_from.pres_coeff, buf_from.disc_layer, buf_from.disc_coeff, buf_from.rigidity, buf_from.rigidity_mask_layer,
      buf_from.delta_x, buf_from.resize_aux_layers, buf_from.resize_canvas, buf_from.new_layer, buf_from.seams, buf_from.grad_func, buf_from.res_order, buf_from.mask_behavior,
      buf_from.oper_mode);
    printf("[ TO ] w,h= %li,%li pl_ID= %li pl_k= %li dl_ID= %li dl_k= %li r= %g ml_ID= %li dx= %li a?= %li c?= %li n?= %li s?= %li gf= %li ro= %li mb= %li om= %li\n",
      buf_to.width, buf_to.height, buf_to.pres_layer, buf_to.pres_coeff, buf_to.disc_layer, buf_to.disc_coeff, buf_to.rigidity, buf_to.rigidity_mask_layer,
      buf_to.delta_x, buf_to.resize_aux_layers, buf_to.resize_canvas, buf_to.new_layer, buf_to.seams, buf_to.grad_func, buf_to.res_order, buf_to.mask_behavior,
      buf_to.oper_mode);
      */

    p_delta_long(&buf.width, buf_from.width, buf_to.width, total_steps, current_step);
    p_delta_long(&buf.height, buf_from.height, buf_to.height, total_steps, current_step);
    buf.pres_layer = buf_to.pres_layer;
    p_delta_long(&buf.pres_coeff, buf_from.pres_coeff, buf_to.pres_coeff, total_steps, current_step);
    buf.disc_layer = buf_to.disc_layer;
    p_delta_long(&buf.disc_coeff, buf_from.disc_coeff, buf_to.disc_coeff, total_steps, current_step);
    p_delta_gfloat(&buf.rigidity, buf_from.rigidity, buf_to.rigidity, total_steps, current_step);
    buf.rigidity_mask_layer = buf_to.rigidity_mask_layer;
    p_delta_long(&buf.delta_x, buf_from.delta_x, buf_to.delta_x, total_steps, current_step);
    buf.resize_aux_layers = buf_to.resize_aux_layers;
    buf.resize_aux_layers = buf_to.resize_aux_layers;
    buf.resize_canvas = buf_to.resize_canvas;
    buf.new_layer = buf_to.new_layer;
    buf.seams = buf_to.seams;
    buf.grad_func = buf_to.grad_func;
    buf.res_order = buf_to.res_order;
    buf.mask_behavior = buf_to.mask_behavior;
    buf.oper_mode = buf_to.oper_mode;
    sstrncpy(buf.pres_layer_name, buf_to.pres_layer_name, VALS_MAX_NAME_LENGTH);
    sstrncpy(buf.disc_layer_name, buf_to.disc_layer_name, VALS_MAX_NAME_LENGTH);
    sstrncpy(buf.rigmask_layer_name, buf_to.rigmask_layer_name, VALS_MAX_NAME_LENGTH);

    
    /*
    printf("[CURR] w,h= %li,%li pl_ID= %li pl_k= %li dl_ID= %li dl_k= %li r= %g ml_ID= %li dx= %li a?= %li c?= %li n?= %li s?= %li gf= %li ro= %li mb= %li om= %li pln=%s\n",
      buf.width, buf.height, buf.pres_layer, buf.pres_coeff, buf.disc_layer, buf.disc_coeff, buf.rigidity, buf.rigidity_mask_layer,
      buf.delta_x, buf.resize_aux_layers, buf.resize_canvas, buf.new_layer, buf.seams, buf.grad_func, buf.res_order, buf.mask_behavior,
      buf.oper_mode, buf.pres_layer_name);
      */

    gimp_set_data("plug_in_lqr", &buf, sizeof(buf)); 

    return 0; /* OK */
}
MAIN ()

/* ----------------------------------------------------------------------
 * install (query) -Iterator
 * ----------------------------------------------------------------------
 */

static void query ()
{
  char l_blurb_text[300];

  static GimpParamDef args_iter[] =
  {
    {GIMP_PDB_INT32, "run_mode", "non-interactive"},
    {GIMP_PDB_INT32, "total_steps", "total number of steps (# of layers-1 to apply the related plug-in)"},
    {GIMP_PDB_FLOAT, "current_step", "current (for linear iterations this is the layerstack position, otherwise some value inbetween)"},
    {GIMP_PDB_INT32, "len_struct", "length of stored data structure with id is equal to the plug_in  proc_name"},
  };
  static int nargs_iter = G_N_ELEMENTS (args_iter);

  static GimpParamDef *return_vals = NULL;
  static int nreturn_vals = 0;

  g_snprintf(l_blurb_text, sizeof(l_blurb_text), "This procedure calculates the modified values for one iterationstep for the call of plug_in_lqr");

  gimp_install_procedure("plug_in_lqr-Iterator",
                         l_blurb_text,
                         "",
                         "Wolfgang Hofer",
                         "Wolfgang Hofer",
                         "29.07.108 03:03",
                         NULL,    /* do not appear in menus */
                         NULL,
                         GIMP_PLUGIN,
                         nargs_iter, nreturn_vals,
                         args_iter, return_vals);

}


/* ----------------------------------------------------------------------
 * run Iterator
 * ----------------------------------------------------------------------
 */


static void
run (const gchar    *name,
     gint      n_params,
     const GimpParam  *param,
     gint     *nreturn_vals,
     GimpParam **return_vals)
{
  static GimpParam values[1];
  GimpRunMode run_mode;
  GimpPDBStatusType status = GIMP_PDB_SUCCESS;
  //gint32     image_id;
  gint32  len_struct;
  gint32  total_steps;
  gdouble current_step;

  gint32     l_rc;

  *nreturn_vals = 1;
  *return_vals = values;
  l_rc = 0;

  run_mode = param[0].data.d_int32;

  if ((run_mode == GIMP_RUN_NONINTERACTIVE) && (n_params == 4))
  {
    total_steps  =  param[1].data.d_int32;
    current_step =  param[2].data.d_float;
    len_struct   =  param[3].data.d_int32;
    l_rc = p_plug_in_lqr_iter(run_mode, total_steps, current_step, len_struct);
    if(l_rc < 0)
    {
       status = GIMP_PDB_EXECUTION_ERROR;
    }
  }
  else status = GIMP_PDB_CALLING_ERROR;

  values[0].type = GIMP_PDB_STATUS;
  values[0].data.d_status = status;

}
